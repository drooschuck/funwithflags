# Application Architecture

This document outlines the technical architecture of the "Fun with Flags" application.

## Overview

"Fun with Flags" is a client-side Single Page Application (SPA) built using React and TypeScript. The architecture now includes Supabase for authentication and a persistent database, evolving from a purely client-side application to a more robust, full-stack solution.

## Component Breakdown

- **`App.tsx`**: The root component. It now manages the user's authentication session with Supabase. It conditionally renders the `AuthPage` for logged-out users or the main application for logged-in users. It also handles a data-syncing process on login.

- **`AuthPage.tsx`**: A new component that provides a user interface for signing up and logging in using Supabase's email and password authentication.

- **`HomePage.tsx`**: The landing page for authenticated users. It now displays a welcome message and includes a sign-out button.

- **`QuizPage.tsx`** & **`FactsPage.tsx`**: These stateful components still manage their respective features, but their data fetching logic has been updated. They now follow a "cache-first" strategy, querying the Supabase database before making a call to the Gemini API.

## Authentication

User authentication is handled entirely by Supabase.
- The `App.tsx` component listens for authentication state changes using `supabase.auth.onAuthStateChange`.
- The `AuthPage.tsx` component uses `supabase.auth.signUp` and `supabase.auth.signInWithPassword` for user management.
- Once a user is logged in, their session is managed by the Supabase client library, and authenticated API requests can be made to the database.

## Data Flow and Persistence

The integration of Supabase introduces a persistent data layer and changes the data flow significantly.

1.  **User Request**: A user asks for a fun fact (in `QuizPage`) or detailed country info (in `FactsPage`).
2.  **Database Query (Cache Check)**: The application first queries the `countries` table in the Supabase database to see if the requested data already exists.
3.  **Return Cached Data**: If the data is found in Supabase, it is returned directly to the client and displayed. The flow stops here.
4.  **API Fallback**: If the data is *not* found in Supabase, the application makes an API call to the Google Gemini API to generate the content.
5.  **Database Write**: The newly fetched data from Gemini is then written back to the Supabase `countries` table.
6.  **Return New Data**: The new data is returned to the client and displayed.

This architecture ensures that each piece of information is generated by the AI only once. Every subsequent request for that same piece of information is served quickly from the database, improving performance and reducing API usage for all users of the application.

### Data Syncing

To ensure the database has a record for every country available in the quiz, a simple sync function runs when a user logs in. It compares the list of countries in the app's `constants.ts` file with the names in the `countries` database table and inserts any missing records. This prepares the database for future data lookups and updates.

## API Integration (Google Gemini)

The use of the Gemini API remains the same as before, serving as the source of truth for generating facts when they are not available in the database cache.

- **Simple Text Generation (`QuizPage`)**: Fetches fun facts.
- **Structured Data Generation (`FactsPage`)**: Fetches detailed country info using a JSON schema.